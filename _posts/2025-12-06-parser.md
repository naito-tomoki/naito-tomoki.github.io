---
layout: default
title: parserの作り方解説
date: 2025-12-06
permalink: /tech/parser/
published: false
---

### parserとは

字句解析してくれたものを構文解析するものです。<br>
字句解析っていうのは、算数の数式を例にすると、これは数字、これは演算子って感じでラベリングするものです。<br>
構文解析はそれを構文木(こうぶんぎ)にしてくれます。

### 構文木とは
構文を木のような構造にすることです。<br>
英語では Syntax Tree っていいます。<br>
説明を省略して先に1 + 2 * 3 + 4という式を例に木のような構造にすると
```
1.   [+]
2.  /   \
3. [1]  [+]
4.     /   \
5.   [*]   [4]
6.  /   \
7. [2]  [3]
```
こんな感じになります。

### 構文木を活用する
上でつくった構文木を、実際に計算するとき、どういう手順を経て計算するのか解説します。<br>
1~3行目から見ていきましょう。
```
1.   [+]
2.  /   \
3. [1]  [+]
```
この + は下に左右に分けてまた構文木を広げます。<br>
一番上の + は左右の値を足した結果になります。<br>
例えば、下の構文木をみてください。
```
    [+]
   /   \
  [3]  [5]
```
このとき、一番上の + は左の3、右の5を足した結果になります。<br>
いうなれば下の状態になります。
```
    [8]
   /   \
  [3]  [5]
```
<br>
これで最初の一行目の意味がわかると思います。
```
1.    [1 + (右の+)]
2.   /             \
3. [1]             [+]
```
上にように表せますね。
<br>
右の + は値が決まってないので、次はそっちに注目していきましょう。
```
3.    [+]
4.   /   \
5. [*]   [4]
```
こんな感じで続いていますね。<br>
これも下のように書き換えることができます。
```
3.    [(左の*) + 4]
4.   /            \
5. [*]            [4]
```
<br>
左の値がわからないので、そこの下を次に見ましょう。
```
5.    [*]
6.   /   \
7. [2]   [3]
```
<br>
これも下のように表せますね。
```
5.   [6 (2 * 3)]
6.  /           \
7. [2]          [3]
```
<br>
これでこの結果がわかったので、上に戻りましょう。
```
3.        [6(左の*) + 4]
4.       /              \
5.  [6 (2 * 3)]         [4]
```
<br>
さらに上に続いてるので戻りましょう。
```
1.   [1 + 10(右の+)]
2.  /              \
3. [1]          [6 + 4]
```
<br>
これで結果がわかったので、全体を見ましょう。
```
1.   [1 + ((2 * 3) + 4)]
2.  /                   \
3. [1]            [(2 * 3) + 4]
4.               /              \
5.           [2 * 3]           [4]
6.          /       \
7.        [2]       [3]
```
<br>
このようにして表すと、
```
1 + 2 * 3 + 4 = 1 + ((2 * 3) + 4)
```
のように表すことができました。<br>
これが構文木です。<br>

### 具体構文木と抽象構文機

構文木とざっくり書きましたが、実は具体構文木という概念と抽象構文機という概念があります<br>

具体構文木は英語で Concrete Syntax Tree: CST っていいます。またパース木 英語で Parse Tree とも言います。<br>
これは完全な文法規則にしたがって、厳密に作られます・・・

抽象構文機は英語で Abstract Syntax Tree: AST って言います。<br>
こちらは具体構文木に比べて人間にわかりやすい感じで表現されます。<br>
また、具体構文木でプログラムを書くのは大変です。<br>
具体構文木は厳密な構文規則に従う一方で、抽象構文機は自分が実行しやすい形で作れます。<br>

数値 12345 の表し方の例として<br>
具体構文木は、数字 0, 1, 2, ..., 9 のどれかを組み合わせて構成されています。<br>
そして、数値は 数字 または 数字と数値 の組み合わせでできます。<br>
つまり、以下のように表すことができます
```
数値 12345 = 数字(1) + 数値(2345)
数値 2345  = 数字(2) + 数値(345)
数値 345   = 数字(3) + 数値(45)
数値 45    = 数字(4) + 数値(5)
数値 5     = 数字(5)
```
その一方で抽象構文機は、これを簡単に扱える、自身のすきな感じで表現できます。<br>
たとえば、数値は数字の羅列だと定義したら簡単そうじゃないですか。<br>
そうすると、以下のように表現することができます。
```
数値 12345 = 数字の羅列(12345)
```
これが具体構文木と抽象構文機の違いです。<br>
<br>
先程の具体構文木の説明で用いた「数値は 数字 または 数字と数値 の組み合わせ」<br>
という説明は非常にややこしいですよね・・・ところがバッカス・ナウア記法を用いると簡単に表すことができます。<br>

### バッカス・ナウア記法

バッカス・ナウア記法はBNFって略されます。<br>
先程の「数値は 数字 または 数字と数値 の組み合わせ」は以下のように表せます。
```
<number> ::= (0|1|2|3|4|5|6|7|8|9) // 数字 は 0または1または2または...9 ということ
<value>  ::= <number> | <number> <value> // 数値 は 数字 または 数字と数値 ということ
```
<br>
ちなみに結構注意しなければいけない部分があり、**左再帰**ということをすると無限ループに陥ります。<br>
<br>
左再帰っていうのは、自分で自分を再起させて、一生終わらない状況に陥ることです。<br>
以下のBNFがあるとします。
```
<A> ::= <A> + <B>
```
Aの値というのは、A + B ですね。つまり、 A = A + B です（？）。<br>
A + B 側の A の値は A = A + B のため A + B です。<br>
その A + B の A の 値は A + B ですね。その A の値は...<br>
<br>
このように無限ループに陥ります。<br>
A = ((((A + B) + B) + B) + B)<br>
この上の式の右辺の A も A + Bです...したがって下のようになります。<br>
```
A = ((((... + B) + B) + B) + B)
```
<br>
parserを作れるようになるためには、バッカス・ナウア記法を自分でかけるようにするのが大事だと思います。<br>

### 四則演算のバッカス・ナウア記法

ぶっちゃけ [https://dai1741.github.io/maximum-algo-2012/docs/parsing/](https://dai1741.github.io/maximum-algo-2012/docs/parsing/) このサイトがマジでおすすめです。<br>
一応１つひとつ開設します。<br>
<br>
小学１年生くらいの概念から始めましょう。<br>
足し算・引き算だけで考えます。<br>
1 + 2 のような式があるとします。<br>
式は英語でfactorです。<br>
まず式で必要なのは数値ですよね。数値を足したり引いたり、掛け算があればかけたり。<br>
少なくとも式なら数値は必須です。<br>
なので、数値 value は次のように表します。<br>
```
<value> ::= [0-9]+
```
[0-9]+ というのは、0~9がいっぱい続くみたいな感じです。<br>
つまり、10だったり、1204だったり、48209だったりも表現できます。<br>
<br>
次に足し算・引き算をバッカス・ナウア記法で表すとき、<br>
足し算・引き算 expr は直感的に以下のように作れると思います。<br>
```
<expr> ::= <value> + <value>
           | <value> - <value>
```
ただ、このような式にすると 1 + 2 + 3 のように次々に右に続く式はつくれないですよね。<br>
そこで、 数値 + 式 のようにすることで、右に式が続くような形にすることができます。<br>
**左再帰**にならないように気をつけましょう。
```
<expr> ::= <value> + <expr>
           | <value> - <expr>
```
しかしながら、これだと右に式をつなげていかないといけないので、無限に式が終わりません。<br>
たとえば、1 + 2 + 3 のような式を作りたいとき value を 1 にします。<br>
式 = 1 + 式 になります。右辺の式は 2 + 3 をつくりたいところです。<br>
そのため右辺の式は BNF 記法に乗っ取ると 式 = 2 + 式 になります。<br>
さらにその右辺の式は 式 = 3 + 式 になります。<br>
その右辺の式は...表現できませんね。<br>
わかりやすく書くと以下のようになってしまいます。<br>
式 = 1 + (2 + (3 + ...)) <br>
<br>
どこかで歯止めをかけるために、好きな長さにできるようにしましょう。<br>
以下のようにすると表せます。
```
<expr> ::= <value> { + <value> }
           | <value> { - <value> }
```
このように {} で囲った中は、好きなだけ続けてもいいという意味になります。<br>
つまり、 1 + 2 + 3 を表したいときは<br>
まず最初に 式 = 1 { + value } のように考えられます。{} 好きな回数続けられるので続けることにしましょう。<br>
次は 1 + 2 にするために、 式 = 1 + 2 { + value } で表せます。また {} は続けてもいいので続けることにします。<br>
1 + 2 + 3 にするために、式 = 1 + 2 + 3 { + value } として表せます。 {} の中はこれ以上続ける必要はないので、これで終わります。<br>
これでうまく 式 = 1 + 2 + 3 を表すことができました。しかしながら、これでもまだ問題があります。<br>
<br>
それは、1 + 2 - 3 のような式をこれでは表すことができません。<br>
というのも、最初に 式を <value> { + <value> } にするか <value> { - <value> } にしなければなりません。<br>
そのため、{ + <value> } 側を選んでしまうと { - <value> } に切り替えることができなくなります。<br>
つまりマイナスを表現することができません。<br>
これを解決するために {} の中で + か - どちらも選択できるようにする必要があります。<br>
以下のように表現すると解決できます。
```
<expr> ::= <value> { (+|-) <value> }
```
これで、1 + 2 - 3 を表そうとすると、まず 式 = 1 { (+|-) <value> } になります。<br>
次に 1 + 2 にするために、{} の中は (+|-) の + を選択して <value> は 2にします。<b r>
そうすると、 式 = 1 + 2 { (+|-) <value> } になります。<br>
そして 1 + 2 - 3 にしたいので、次の {} の中は (+|-) の - を選択して <value> は 3にします。<br>
こうすると 式 = 1 + 2 - 3 { (+|-) <value> } になり、もう続ける必要はないのでこれで完成です。<br>
式 = 1 + 2 - 3 とうまく表せました。<br>
<br>
次に掛け算と割り算を使いたいので、 term というので表すことにします。<br>
まずは足し算と引き算を考慮せずに掛け算と割り算だけを考えることにします。<br>
すると、先程の足し算と引き算の BNF から以下のように表現できます。<br>
```
<term> ::= <value> { (*|/) <value> }
```
これなら例えば 1 / 2 * 3 もうまく表せそうです。<br>